package infinitton

import (
	"image"

	"github.com/tehmaze/benjamin/deck"
	"github.com/tehmaze/benjamin/internal/imageutil"
	"golang.org/x/image/draw"
)

type key struct {
	index  int
	device *iDisplay
}

func newKey(d *iDisplay, index int) *key {
	return &key{
		index:  index,
		device: d,
	}
}

func (k *key) Position() image.Point {
	return image.Pt(k.index%3, k.index/3)
}

func (k *key) Size() image.Point {
	return k.device.KeySize()
}

func (k *key) Surface() deck.Surface {
	return k.device
}

func (k *key) Update(i image.Image) error {
	o := imageutil.NewBGR(image.Rectangle{Max: image.Pt(72, 72)})
	draw.BiLinear.Scale(o, o.Rect, i, i.Bounds(), draw.Src, nil)

	return k.writePixelData(o.Pix)
}

var (
	headerPixelsPage1 = []byte{
		0x02, 0x00, 0x00, 0x00, 0x00, 0x40, 0x1f, 0x00,
		0x00, 0x55, 0xaa, 0xaa, 0x55, 0x11, 0x22, 0x33,
		0x44, 0x42, 0x4d, 0xf6, 0x3c, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x36, 0x00, 0x00, 0x00, 0x28,
		0x00, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00, 0x48,
		0x00, 0x00, 0x00, 0x01, 0x00, 0x18, 0x00, 0x00,
		0x00, 0x00, 0x00, 0xc0, 0x3c, 0x00, 0x00, 0x13,
		0x0b, 0x00, 0x00, 0x13, 0x0b, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	}
	headerPixelsPage2 = []byte{
		0x02, 0x40, 0x1f, 0x00, 0x00, 0xb6, 0x1d, 0x00,
		0x00, 0x55, 0xaa, 0xaa, 0x55, 0x11, 0x22, 0x33,
		0x44,
	}
)

func (k *key) writePixelData(b []byte) error {
	var (
		p1   = b[:7946]
		p2   = b[7946:]
		kidx = byte(k.index) + 1
	)
	if err := k.writePixelDataPage(headerPixelsPage1, p1); err != nil {
		return err
	}
	if err := k.writePixelDataPage(headerPixelsPage2, p2); err != nil {
		return err
	}

	r := []byte{
		0x00, 0x12, 0x01, 0x00, 0x00, kidx, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xf6, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00,
	}
	if _, err := k.device.dev.SendFeatureReport(r); err != nil {
		return err
	}
	return nil
}

const pagePacketSize = 8017

func (k *key) writePixelDataPage(h, p []byte) error {
	b := make([]byte, pagePacketSize)

	// Write header
	copy(b, h)

	// Write payload
	copy(b[len(h):], p)

	// Send packet
	_, err := k.device.dev.Write(p)
	return err
}
